---
title: 'Using recursion to create a nested comments system (ft. ReactJS)'
date: '2024-02-28'
tags: ['data structures', 'algorithms', 'recursion']
draft: false
summary: 'build a recursive comment section with reactjs'
---

# Introduction

Recursive thinking is one of the crazy rides in the DSA journey. Beyond just **figuring out the base and recursive cases**, the mechanics easily gets out of control, making it challenging to trace the flow properly. Whereas loops may, in some cases, be more applicable, recursion beats the game with elegance! (although, with memory trade-offs)

Moreover, there are problems that are just too difficult or even impossible to solve without recursion. Example of such is the focus of this post. Note that this post is not to teach you about recursion.

Hence, to feel comfortable following through to the end, you must fit the following profile.

1. You know the basics of recursion and have solved a few simple questions around it

2. You have some knowledge of trees and how to perform a depth-first search/traversal

3. You know basic ReactJs and Typescript (states, props, map, filter)

Here is a [live link](https://nested-comments-react.netlify.app) to the final version of the nested comments system.

Also, note that this post doesn't highlight anything about styling, layout and other aesthetics you might see in the final version. The full code is hosted on this [github link](https://github.com/faddalibrahim/nested-comments-system-react) for your perusal.

So what is expected in this post?

1. Build out the logic for the behavior of the comments system using textbook/classroom knowledge
2. Build a setup and the basic ReactJS components needed to get it functional.

Find below the roadmap

## PART 1 : Foundational Logic

### A simple recursive function

This function is going to be a foundational reference point and a low-level template for how our nested comments system will behave. It takes a positive integer as input, then it prints the integer and all other positive integers less than the input. Let's call it `printNumberLadder`

```ts:printNumberLadder.ts
function printNumberLadder(num: number) {
  // base case
  if (num <= 0) return

  // recursive case
  console.log(num)
  printNumberLadder(num - 1)
}
```

**Result**

![Recursive Function](/static/images/nested-comments/basic-recursive-func.svg)

The recursive flow of this function mimics the behavior of our comments system -- We render a parent comment, then proceed to render all the sub comments in it.

Comparing that with the comment system,

The **Base Case**, `if num <= 0` is linguistically similar to `if there are no more sub comments...`

The **Recursive Case** `pNL(num - 1)` is similar to `call the next comment below this one`

Translating the previous code to reflect a comments system, we have..

```ts:logComment.ts
function logComment(comment) {
  // base case : stop if there are no more comments or child comments
  if (!comment || !comment.child) return

  // recursive : display the current comment and call its direct child comment
  console.log(comment.text)
  logComment(comment.child)
}
```

However, the above setup doesn't work. It makes sense if there is just one parent comment that has a single child comment, which in turn has a single child comment and so on.

But NO! In reality, there are multiple top level comments. Each top level comment has a number of children. Each child has its own children and so on. Therefore we have a TREE! And how do we traverse trees? You right! **DFS/BFS**.

![Comment Tree Illustration](/static/images/nested-comments/comment-tree.svg)

### Depth-First-Search/Traversal

Now that we are aware we are dealing with a tree, we know we need to traverse recursively with **DFS** to perform any operations on the comment tree (deleting, printing etc). So, let's modify the `logComment` function to do just that

Before that, here is are some key preparations to note.

1. The main components of a comment - a `text` and `children/sub comments`. The sub comments/children are what we linguistically call a reply. But lets call them children for the sake of technicality.

```ts
interface Comment {
  text: string
  children: Comment[] | null
}
```

2. On comments sections on social media, there isnt a starting root comment from which all others branch out. Its rather a list of independent `Top-Level` comments written by different users. Its from these `Top-Level` comments that other users may choose to reply to.

So, there is literally no ROOT. But we can create an imaginary ROOT comment. This imaginary root will have no `text`, but its children will be the `Top-Level` Comments. This makes it easy to pass a ROOT to initiate the recursive chain.

![Comment Tree Illustration](/static/images/nested-comments/imaginary-root.svg)

```ts:logCommentDFS.ts
function logCommentDFS(comment: Comment) {
  // base case
  if (!comment) return

  // recursive case with DFS
  for (let i = 0; i < comment.children.length; i++) {
    console.log(comment.text)
    logComment(comment.children[i])
  }
}
```

### Space & Time Complexity

## PART 2: Building the comments system

### Structure of a Comment data

Here, we extend the previous to interface to include relevant data like **id**, **user**, **dates** etc.

```ts
interface User {
  id: string
  name: string
  profileImg: string
}

interface Comment {
  id: string
  text: string
  user: User
  replies: Comment[]
  createdAt: Date
  modifiedAt: Date
}
```

### Comment Block Component

This is the visual representation of a single comment. It is what users would see and interact with. It takes a comment data as an input prop and renders it on the screen.

Additionally, this block component will recursively render any replies/sub-comments for the main comment.

```tsx:CommentBlock.tsx

export default function CommentBlock(comment: Comment){
  return (
    <div>
      <p>{comment.text}</p>
      <div>
        <button>reply</button>
        <button>delete</button>
      </div>

      {/**Recursive rendering of replies*/}
      {
        comment.replies.length != 0 && comment.replies.map(
          (reply: Comment) => <CommentBlock comment={reply}/>
        )
      }
    </div>
  )
}

```

### Rendering Comments To The Screen

The CommentThread.tsx component takes a an array of comments.

This is the initial call that starts the recursive chain!

It loops through the TopLevel Comments and recursively calls their children.

```tsx:CommentThread.tsx
export default function CommentBlocks(topLevelComments){
  return(
    {topLevelComments.length > 0 ? (
      topLevelComments.map(comment => <CommentBlock comment={comment}/>)
      ) : (<p>no comments</p>)

    }
  )
}
```

### Adding a Top-Level Comment

A top-level comment is a comment that is not a reply.

```ts
function addTopLevelComment(commentText){
  setAllComments((prevComments) => [new Comment(commentText), ..prevComments.])
}

```

### Adding a Child Comment (Reply)

Here is where we need to think critically

we need to know

1. the parent comment to which we are attaching the reply to

```ts
function addChildComment(commentText, parentId) {}
```

### Combining addChildComment and addTopLevelComment

```ts
function addComment(commentText: string, parentId: string) {
  // top level comment
  if (!parentId) {
    addTopLevelComment(commentText)
    return
  }

  // child comment (reply)
  addChildComment(commentText, parentId)
}
```

### Deleting a comment

### Editting a comment

## Problems

call stack problems

### Conclusion

The final version can be found here. Its a bit more complex that the simple demonstration here. I had to use context to prevent prop drilling.

Interesting Things you can add

- connect to a backend (firebase)
- limit the number of replies that show (show more button)

# React Diagram
