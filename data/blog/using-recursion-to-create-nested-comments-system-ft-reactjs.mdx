---
title: 'Using recursion to create a nested comments system (ft. ReactJS)'
date: '2024-02-28'
tags: ['data structures', 'algorithms', 'recursion']
draft: false
summary: 'build a recursive comment section with reactjs'
---

# Introduction

Recursive thinking is one of the crazy rides in the DSA journey. Beyond just **figuring out the base and recursive cases**, the mechanics easily gets out of control, making it challenging to trace the flow properly. Whereas loops may, in some cases, be more applicable, recursion beats the game with elegance! (although, with memory trade-offs)

Moreover, there are problems that are just too difficult or even impossible to solve without recursion. Example of such is the focus of this post. Note that this post is not to teach you about recursion.

Hence, to feel comfortable following through to the end, you must fit the following profile.

1. You know the basics of recursion and have solved a few simple questions around it

2. You have some knowledge of trees and how to perform a depth-first search/traversal

3. You know basic ReactJs and Typescript (states, props, map, filter)

Here is a [live link](https://nested-comments-react.netlify.app) to the final version of the nested comments system.

Also, note that this post doesn't highlight anything about styling, layout and other aesthetics you might see in the final version. The full code is hosted on this [github link](https://github.com/faddalibrahim/nested-comments-system-react) for your perusal.

So what is expected in this post?

1. Build out the logic for the behavior of the comments system using textbook/classroom knowledge
2. Build a setup and the basic ReactJS components needed to get it functional.

Find below the roadmap

## PART 1 : Foundational Logic

### A simple recursive function

This function is going to be a foundational reference point and a low-level template for how our nested comments system will behave. It takes a positive integer as input, then it prints the integer and all other positive integers less than the input. Let's call it `printNumberLadder`

```ts:printNumberLadder.ts
function printNumberLadder(num: number) {
  // base case
  if (num <= 0) return

  // recursive case
  console.log(num)
  printNumberLadder(num - 1)
}

printNumberLadder(3);
```

**Result**

![Recursive Function](/static/images/nested-comments/basic-recursive-func.svg)

The recursive flow of this function mimics the behavior of our comments system -- We render a parent comment, then proceed to render all the sub comments in it by recursively calling its sub-comments.

Comparing that with a potential comment system,

The **Base Case**, `if num <= 0` is linguistically similar to `if there are no more sub comments...`

The **Recursive Case** `pNL(num - 1)` is similar to `call the next comment below this one`

Translating the previous code to reflect a comments system, we have..

```ts:logComment.ts
interface Comment{
  text: string
  child: Comment | null
}

function logComment(comment: Comment) {
  /**
   * BASE CASE
   * stop if there are no more child comments
  */
  if (comment === null) return


  console.log(comment.text)

  /**
   * RECURSIVE CASE
   * call the next child comment
  */
  logComment(comment.child)
}
```

However, the above setup doesn't work. It makes sense if there is just one parent comment that has a single child comment, which in turn has a single child comment and so on.

But NO! In reality, there are multiple comments. Each comment has a number of children (replies). Each child has its own children and so on. Therefore we have a **TREE**! And how do we traverse trees? You are right! **DFS or BFS**.

![Comment Tree Illustration](/static/images/nested-comments/comment-tree.svg)

### Depth-First-Search/Traversal

Now that we are aware that we are dealing with a tree, we know we need to traverse recursively in a **depth-first** fashion to perform any operations on the comment tree (deleting, printing etc). So, let's modify the `logComment` function to do just that

Before that, here are some key reminders to note.

1. The main components of a comment - a `text` and `children/sub comments`. The sub comments/children are what we linguistically call a reply. But lets call them children for the sake of technicality.

```ts
interface Comment {
  text: string
  children: Comment[] | null
}
```

2. For comments sections on social media, there isnt a starting root comment from which all others branch out. Its rather a list of independent `Top-Level` comments written by different users. Its from these `Top-Level` comments that other users may choose to reply to.

So, there is literally no ROOT. But we can create an imaginary/fake ROOT comment. This imaginary/fake root will have no `text`, but its children will be these `Top-Level` Comments. It makes it easy to pass a ROOT to initiate the recursive chain.

![Comment Tree Illustration](/static/images/nested-comments/imaginary-root.svg)

```ts:logCommentDFS.ts
function logCommentDFS(comment: Comment) {
  // base case
  if (!comment) return

  // recursive case with DFS
  for (let i = 0; i < comment.children.length; i++) {
    console.log(comment.text)
    logComment(comment.children[i])
  }
}
```

### Space & Time Complexity

## PART 2: Building the APP

Below is a visual representation of the app. Starting from innermost component, I will explain what happens at each level.

![React App Hierarchy](/static/images/nested-comments/react-app-hierarchy.svg)

### Structure of a Comment data

Here, we extend the previous to interface to include relevant data like **id**, **user**, **dates** etc.

```ts
interface User {
  id: string
  name: string
  profileImg: string
}

interface Comment {
  id: string
  text: string
  user: User
  replies: Comment[]
  createdAt: Date
  modifiedAt: Date
}
```

### CommentBlock.tsx Component : Renders a single comment

The **CommentBlock.tsx** component is the visual representation of a single comment. It is what users would see and interact with. It takes a comment data as an input prop and renders it on the screen.

Additionally, this component will recursively render any replies/sub-comments for the current comment.

```tsx:CommentBlock.tsx

export default function CommentBlock({comment}){
  return (
    <div>
      <p>{comment.text}</p>
      <div>
        <button>reply</button>
        <button>delete</button>
      </div>

      {/**Recursive rendering of comment replies*/}
      {
        comment.replies.length > 0 && comment.replies.map(
          (reply: Comment) => <CommentBlock comment={reply}/>
        )
      }
    </div>
  )
}

```

### Rendering All Comments To The Screen

We will call this component `CommentThread.tsx`.

It will take an array of all the comments, loop through and render them to the screen by passing each comment's data to `CommentBlock.tsx`

By looping through and passing each comment's data to `CommentBlock.tsx`, it starts the recursive chain that results in the rendering of sub comments for each parent comment and so on.

```tsx:CommentThread.tsx
export default function CommentThread({allComments}) {
    return allComments.map((comment: Comment) => <CommentBlock key={comment.id} comment={comment}/>)
  }
}
```

### Adding a comment to the tree

In the previous paragraphs, we have been passing comments through to our components. But where are those comment data coming from? Since we are dealing with, ReacJS, we need to store these comments in a state.

```tsx:CommentSection.tsx
export default function CommentSection(){

  const [allComments] = useState<Comment[]>(dummyCommentData);

  return <CommentThread allComments={allComments}/>
}
```

```tsx:CommentSection.tsx
export default function CommentSection(){

  const [allComments, setAllComments] = useState<Comment[]>(dummyCommentData);

  return <CommentThread
            allComments={allComments}
            setAllComments={setAllComments}
          />
}
```

```ts

import useState from "react"


function addTopLevelComment(commentText){
  setAllComments((prevComments) => [new Comment(commentText), ..prevComments.])
}

```

### Adding a Child Comment (Reply)

Here is where we need to think critically

we need to know

1. the parent comment to which we are attaching the reply to

```ts
function addChildComment(commentText, parentId) {}
```

### Combining addChildComment and addTopLevelComment

```ts
function addComment(commentText: string, parentId: string) {
  // top level comment
  if (!parentId) {
    addTopLevelComment(commentText)
    return
  }

  // child comment (reply)
  addChildComment(commentText, parentId)
}
```

### Deleting a comment

### Editting a comment

## Problems

call stack problems

### Conclusion

The final version can be found here. Its a bit more complex that the simple demonstration here. I had to use context to prevent prop drilling.

Interesting Things you can add

- connect to a backend (firebase)
- limit the number of replies that show (show more button)

# React Diagram
