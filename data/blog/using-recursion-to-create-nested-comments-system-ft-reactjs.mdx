---
title: 'Using recursion to create a nested comments system (ft. ReactJS)'
date: '2024-02-28'
tags: ['data structures', 'algorithms', 'recursion']
draft: false
summary: 'build a recursive comment section with reactjs'
---

# Introduction

Recursive thinking is one of the crazy rides in every DSA journey. Beyond just **figuring out the base and recursive cases**, the mechanics easily gets out of control, making it challenging to trace the flow properly. Whereas loops may, in some cases, be more applicable, recursion beats the game with elegance! (although, with memory trade-offs)

Moreover, there are problems that are just too difficult or even impossible to solve without recursion. Example of such is the focus of this post. Note that this post is not to teach you about recursion.

Hence, to feel comfortable following through to the end, you must fit the following profile.

1. You know the basics of recursion and have solved a few simple questions around it

2. You have some knowledge of trees and how to perform a depth-first search/traversal

3. You know basic ReactJs and Typescript (states, props, map, filter)

Here is a [live link](https://nested-comments-react.netlify.app) to the final version of the nested comments system built with react.

Also, note that this post doesn't highlight anything about styling, layout and other aesthetics you might see in the final version. The full code is hosted on this [github link](https://github.com/faddalibrahim/nested-comments-system-react) for your perusal.

So what is expected in this post?

1. Build out the logic for the behavior of the comments system using textbook/classroom knowledge
2. Build a setup and the basic ReactJS components needed to get it functional.

Find below the roadmap

## Foundational Logic

### A simple recursive function

This function is going to be a foundational reference point and a low-level template for how our nested comments system will behave. It takes an input positive integer, then it prints the integer and all other positive integers less than the input. Let's call it `printNumberLadder`

```ts
function printNumberLadder(num: number) {
  // base case
  if (num <= 0) return

  // recursive case
  console.log(num)
  printNumberLadder(num - 1)
}
```

![Recursive Function](/static/images/nested-comments/basic-recursive-func.svg)

The recursive flow of this function mimics the behavior of our comments system. We render a parent comment, then proceed to render all the sub comments in it.

The base case, `if num <= 0` is similar to `if there are no more sub comments`
the recursive case `pNL(num - 1)` is similar to `call the next child comment that is below the current comment`

Translating this to reflect our comments system, we have

```ts
function logComment(comment) {
  // base case : stop if there are no more comments or child comments
  if (!comment || !comment.child) return

  // recursive : display the current comment and call its direct child comment
  console.log(comment.text)
  logComment(comment.child)
}
```

However, the above setup doesn't work. It makes sense if there is just one parent comment that has a single child comment, which in turn has a single child comment and so on, as illustrated in the diagram below

But NO! In reality, there are multiple top level comments. Each top level comment has a number of children. Each child has its own children and so on. Therefore we have a TREE! And how do we traverse trees? You right! DFS/BFS. Wow That escalated so quickly!

### Depth-First Traversal

Now that we are aware we are dealing with a tree, the puzzle pieces should have connected themselves enough for you to conclude that to perform any operation on the comments system (printing, deleting, adding, editting) , we need to traverse the comment tree recursively with DFS. So, let's modify the `logComment` function to do just that

A comment is made up of `comment text` and its `children`

```ts
interface Comment {
  text: string
  children: Comment[] | null
}

function logComment(comment: Comment) {
  // base case
  if (!comment) return

  // recursive case with DFS
  for (let i = 0; i < comment.children.length; i++) {
    console.log(comment.text)
    logComment(comment.children[i])
  }
}
```

The above function looks alright, but a little problematic. Its true that we are dealing with a TREE, and trees have ROOTS. So to start our DFS, we pass the root as the primary argument to start the recursive chain. But, remember, in a comment system, there are multiple Top-Level Comments. Its not as though there is a single root comment, and all other comments fall below it. Therefore, the ROOT that will be passed as the argument to the inital call of the function will be an ARRAY of all the TOP-LEVEL COMMENTS

![Comment Structure Illustration](/static/images/nested-comments/comment-structure.png)

```ts
interface Comment {
  text: string
  children: Comment[] | null
}

function initLogComment(comments: Comment[]) {
  // base case
  if (!comment) return

  // recursive case with DFS
  for (let i = 0; i < comment.children.length; i++) {
    console.log(comment.text)
    logComment(comment.children[i])
  }
}
```

### DIAGRAM

Lets modify the previous function to reflect reality,

It basically becomes a depth-first traversal through the comment object to print the comment tree

### Comment Tree

### DFS

Now that we are aware that we are dealing with a tree, we pick the right tool from our toolbox to traverse it. Lets go with DFS so that we can recursivly remove and add new comment nodes to our tree.

### Space & Time Complexity

## Building the comments system

### Structure of a Comment data

Here are a few things

```ts
interface User {
  id: uuid
  name: string
  profileImg: string
}

interface CommentBlock {
  id: uuid
  text: string
  user: User
  replies: CommentBlock[]
  createdAt: Date
  modifiedAt: Date
}
```

### Comment Component

If we are fetching comments from an api, this

```tsx:CommentBlock.tsx

export default function CommentBlock(){
  return (
    <div>
      <p>{comment.text}</p>
      <div>
        <button>edit</button>
        <button>reply</button>
        <button>delete</button>
      </div>
      {
        comment.replies.length != 0 && comment.replies.map((reply: CommentBlock) => <CommentBlock key={id} comment={reply}/>)
      }
    </div>
  )
}

```

### Rendering Comments

```tsx:CommentBlocks.tsx


export default function CommentBlocks(){
  const [allComments, setAllComments]= useState<CommentBlock[]>([])

  return(
    {allComments.length > 0 ? (
      allComments.map(comment => <CommentBlock comment={comment}/>)
      ) : (<p>no comments</p>)

    }
  )
}

```

### Adding a Top-Level Comment

A top-level comment is a comment that is not a reply.

```ts
function addTopLevelComment(commentText){
  setAllComments((prevComments) => [new Comment(commentText), ..prevComments.])
}

```

### Adding a Child Comment (Reply)

Here is where we need to think critically

we need to know

1. the parent comment to which we are attaching the reply to

```ts
function addChildComment(commentText, parentId) {}
```

### Combining addChildComment and addTopLevelComment

```ts
function addComment(commentText: string, parentId: string) {
  // top level comment
  if (!parentId) {
    addTopLevelComment(commentText)
    return
  }

  // child comment (reply)
  addChildComment(commentText, parentId)
}
```

### Deleting a comment

### Editting a comment

## Problems

call stack problems

### Conclusion

The final version can be found here. Its a bit more complex that the simple demonstration here. I had to use context to prevent prop drilling.

Interesting Things you can add

- connect to a backend (firebase)
- limit the number of replies that show (show more button)

# React Diagram
